use traj_dist_rs::distance::{distance_type::DistanceType, hausdorff::hausdorff};

fn main() {
    // 失败的测试用例（第 1 行）
    let traj1: Vec<[f64; 2]> = vec![
        [-122.39548, 37.77668],
        [-122.39712, 37.7755],
        [-122.40248, 37.77245],
        [-122.40894, 37.77763],
        [-122.41364, 37.78094],
        [-122.41556, 37.78265],
        [-122.42042, 37.78208],
        [-122.42206, 37.78187],
        [-122.43247, 37.78053],
        [-122.43245, 37.78051],
    ];

    let traj2: Vec<[f64; 2]> = vec![
        [-122.39537, 37.77663],
        [-122.3929, 37.77893],
        [-122.39795, 37.78312],
        [-122.40267, 37.78708],
        [-122.40386, 37.78857],
        [-122.40467, 37.79137],
        [-122.41037, 37.79099],
        [-122.41717, 37.79008],
        [-122.42178, 37.78956],
        [-122.42393, 37.79004],
        [-122.42491, 37.79461],
        [-122.4255, 37.79755],
        [-122.42565, 37.79823],
    ];

    println!("轨迹1:");
    for (i, point) in traj1.iter().enumerate() {
        println!("  点 {}: {:?}", i, point);
    }

    println!("\n轨迹2:");
    for (i, point) in traj2.iter().enumerate() {
        println!("  点 {}: {:?}", i, point);
    }

    // 计算 Hausdorff 距离
    let distance = hausdorff(&traj1, &traj2, DistanceType::Euclidean);
    println!("\nHausdorff 距离: {}", distance);
    println!("期望距离: 0.016684455103653763");
    println!("误差: {}", (distance - 0.016684455103653763).abs());
}
